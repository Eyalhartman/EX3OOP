dana_weitz,eyalshim
322447822,318657012

1.In our application, each component fulfills a clear role and they all work together: the Image class handles loading, saving and pixel access; ImageProcessor provides static functions for padding, splitting into tiles and computing average brightness, which the AsciiArtAlgorithm uses to break the image into segments; CharConverter transforms characters into BufferedImage objects and into a boolean matrix for brightness measurement; RoundingMode (enum) defines how brightness values are rounded and is supplied to SubImgCharMatcher, which builds a mapping from each character to its computed (and normalized) brightness and returns the appropriate character for each brightness level; the algorithm within AsciiArtAlgorithm then takes the tiles from ImageProcessor, computes their brightness, and uses SubImgCharMatcher to assemble a char[][] matrix of ASCII art; and finally, Shell manages user commands—selecting the character set, resolution and rounding mode—instantiates both the matcher and the AsciiArtAlgorithm, and prints or saves the result.
2. We used ArrayList<Character> in SubImgCharMatcher to store the list of characters in order of increasing brightness. Chosen for its fast O(1) access by index, which is essential for mapping brightness levels to characters efficiently.
We used HashMap<Character, Double> in SubImgCharMatcher to map each character to its  brightness value. Offers average-case O(1) time for updates and lookups, which is crucial when dynamically adding or removing characters.
We used TreeMap<Character, Double> in SubImgCharMatcher after normalization to ensure characters are kept in ASCII-sorted order. Provides O(log n) operations and allows ordered iteration, which simplifies consistent output when needed.
We used TreeSet<Character> in Shell to maintain the current working character set. It automatically avoids duplicates and maintains order with O(log n) operations, ideal for supporting sorted output in the chars command.
We used HashMap<Integer, Double> in AsciiArtAlgorithm to store brightness values of sub-images that were already computed earlier, so that if the same sub-image is processed again, the value can be retrieved quickly with O(1) access instead of recalculating it. This improves performance and reduces unnecessary computations.
3. We used Java's exception handling mechanism — specifically try-catch blocks — to catch and respond to invalid user inputs without crashing the program. For example, in the Shell class, if the user enters a command (like add without a character, or invalid resolution values), the program catches the exception and prints a descriptive error message.
This separation between input processing and error handling ensures the program remains stable and user-friendly, even when the input is incorrect.
4. We made changes to the SubImgCharMatcher API to support dynamic interaction with it via the Shell class. we added a roundingMode field along with setRoundingMode() and getRoundingMode() methods. This allows the user to control how brightness values are mapped to characters — whether by rounding up, down, or to the nearest index.
These additions were essential to allow runtime configuration of the matching behavior, as required by the user interface design.
5. We did not modify any of the classes that were provided